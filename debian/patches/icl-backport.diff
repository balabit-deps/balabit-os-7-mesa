cherry-picked/backported patches:

804d1bd111fdb5f i965/icl: Apply WA_1606682166 to compute workloads
db093d028c6383d i965/icl: Fix WA_1606682166
e334a595e41b6b0 intel/icl: Add new ICL PCI-IDs
30fa15e36b031f4 anv,i965: Stop warning about incomplete gen11 support
f8c3f408a6026f2 intel/genxml: Update MI_ATOMIC genxml definition.
11518384c465b9f i965: Re-enable fast color clears for GEN11.
9175c7058efb13d intel/blorp: Make blorp update the clear color in gen11.
232c0f64891e2f9 isl: Set ClearColorConversionEnable.
f2041d2a9266ec1 intel/isl: Resize clear color buffer to full cacheline
ff642fb0e6523db intel/compiler/fs/icl: Use dummy masked urb write for tess eval
ea42ba36b936e26 intel/compiler/icl: Use tcs barrier id bits 24:30 instead of 24:27

diff --git a/include/pci_ids/i965_pci_ids.h b/include/pci_ids/i965_pci_ids.h
index b91abd7a3f9..17b5f5517eb 100644
--- a/include/pci_ids/i965_pci_ids.h
+++ b/include/pci_ids/i965_pci_ids.h
@@ -204,6 +204,8 @@ CHIPSET(0x5A54, cnl_5x8, "Intel(R) HD Graphics (Cannonlake 5x8 GT2)")
 CHIPSET(0x8A50, icl_8x8, "Intel(R) HD Graphics (Ice Lake 8x8 GT2)")
 CHIPSET(0x8A51, icl_8x8, "Intel(R) HD Graphics (Ice Lake 8x8 GT2)")
 CHIPSET(0x8A52, icl_8x8, "Intel(R) HD Graphics (Ice Lake 8x8 GT2)")
+CHIPSET(0x8A53, icl_8x8, "Intel(R) HD Graphics (Ice Lake 8x8 GT2)")
+CHIPSET(0x8A54, icl_6x8, "Intel(R) HD Graphics (Ice Lake 6x8 GT1.5)")
 CHIPSET(0x8A56, icl_4x8, "Intel(R) HD Graphics (Ice Lake 4x8 GT1)")
 CHIPSET(0x8A57, icl_6x8, "Intel(R) HD Graphics (Ice Lake 6x8 GT1.5)")
 CHIPSET(0x8A58, icl_4x8, "Intel(R) HD Graphics (Ice Lake 4x8 GT1)")
diff --git a/src/intel/blorp/blorp_genX_exec.h b/src/intel/blorp/blorp_genX_exec.h
index 152f40d9338..67076a15653 100644
--- a/src/intel/blorp/blorp_genX_exec.h
+++ b/src/intel/blorp/blorp_genX_exec.h
@@ -130,12 +130,13 @@ _blorp_combine_address(struct blorp_batch *batch, void *location,
         _blorp_cmd_pack(cmd)(batch, (void *)_dst, &name),         \
         _dst = NULL)
 
-#define blorp_emitn(batch, cmd, n) ({                       \
+#define blorp_emitn(batch, cmd, n, ...) ({                  \
       uint32_t *_dw = blorp_emit_dwords(batch, n);          \
       if (_dw) {                                            \
          struct cmd template = {                            \
             _blorp_cmd_header(cmd),                         \
             .DWordLength = n - _blorp_cmd_length_bias(cmd), \
+            __VA_ARGS__                                     \
          };                                                 \
          _blorp_cmd_pack(cmd)(batch, _dw, &template);       \
       }                                                     \
@@ -1729,7 +1730,42 @@ blorp_update_clear_color(struct blorp_batch *batch,
                          enum isl_aux_op op)
 {
    if (info->clear_color_addr.buffer && op == ISL_AUX_OP_FAST_CLEAR) {
-#if GEN_GEN >= 9
+#if GEN_GEN == 11
+      blorp_emit(batch, GENX(PIPE_CONTROL), pipe) {
+         pipe.CommandStreamerStallEnable = true;
+      }
+
+      /* 2 QWORDS */
+      const unsigned inlinedata_dw = 2 * 2;
+      const unsigned num_dwords = GENX(MI_ATOMIC_length) + inlinedata_dw;
+
+      struct blorp_address clear_addr = info->clear_color_addr;
+      uint32_t *dw = blorp_emitn(batch, GENX(MI_ATOMIC), num_dwords,
+                                 .DataSize = MI_ATOMIC_QWORD,
+                                 .ATOMICOPCODE = MI_ATOMIC_OP_MOVE8B,
+                                 .InlineData = true,
+                                 .MemoryAddress = clear_addr);
+      /* dw starts at dword 1, but we need to fill dwords 3 and 5 */
+      dw[2] = info->clear_color.u32[0];
+      dw[4] = info->clear_color.u32[1];
+
+      clear_addr.offset += 8;
+      dw = blorp_emitn(batch, GENX(MI_ATOMIC), num_dwords,
+                                 .DataSize = MI_ATOMIC_QWORD,
+                                 .ATOMICOPCODE = MI_ATOMIC_OP_MOVE8B,
+                                 .CSSTALL = true,
+                                 .ReturnDataControl = true,
+                                 .InlineData = true,
+                                 .MemoryAddress = clear_addr);
+      /* dw starts at dword 1, but we need to fill dwords 3 and 5 */
+      dw[2] = info->clear_color.u32[2];
+      dw[4] = info->clear_color.u32[3];
+
+      blorp_emit(batch, GENX(PIPE_CONTROL), pipe) {
+         pipe.StateCacheInvalidationEnable = true;
+         pipe.TextureCacheInvalidationEnable = true;
+      }
+#elif GEN_GEN >= 9
       for (int i = 0; i < 4; i++) {
          blorp_emit(batch, GENX(MI_STORE_DATA_IMM), sdi) {
             sdi.Address = info->clear_color_addr;
diff --git a/src/intel/compiler/brw_fs_nir.cpp b/src/intel/compiler/brw_fs_nir.cpp
index 6f0d9731cfe..b0750dce2b6 100644
--- a/src/intel/compiler/brw_fs_nir.cpp
+++ b/src/intel/compiler/brw_fs_nir.cpp
@@ -2318,16 +2318,26 @@ fs_visitor::nir_emit_tcs_intrinsic(const fs_builder &bld,
       /* Zero the message header */
       bld.exec_all().MOV(m0, brw_imm_ud(0u));
 
-      /* Copy "Barrier ID" from r0.2, bits 16:13 */
-      chanbld.AND(m0_2, retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD),
-                  brw_imm_ud(INTEL_MASK(16, 13)));
+      if (devinfo->gen < 11) {
+         /* Copy "Barrier ID" from r0.2, bits 16:13 */
+         chanbld.AND(m0_2, retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD),
+                     brw_imm_ud(INTEL_MASK(16, 13)));
 
-      /* Shift it up to bits 27:24. */
-      chanbld.SHL(m0_2, m0_2, brw_imm_ud(11));
+         /* Shift it up to bits 27:24. */
+         chanbld.SHL(m0_2, m0_2, brw_imm_ud(11));
+      } else {
+         chanbld.AND(m0_2, retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD),
+                     brw_imm_ud(INTEL_MASK(30, 24)));
+      }
 
       /* Set the Barrier Count and the enable bit */
-      chanbld.OR(m0_2, m0_2,
-                 brw_imm_ud(tcs_prog_data->instances << 9 | (1 << 15)));
+      if (devinfo->gen < 11) {
+         chanbld.OR(m0_2, m0_2,
+                    brw_imm_ud(tcs_prog_data->instances << 9 | (1 << 15)));
+      } else {
+         chanbld.OR(m0_2, m0_2,
+                    brw_imm_ud(tcs_prog_data->instances << 8 | (1 << 15)));
+      }
 
       bld.emit(SHADER_OPCODE_BARRIER, bld.null_reg_ud(), m0);
       break;
diff --git a/src/intel/compiler/brw_fs_visitor.cpp b/src/intel/compiler/brw_fs_visitor.cpp
index 51a0ca2374a..e6a7a68410b 100644
--- a/src/intel/compiler/brw_fs_visitor.cpp
+++ b/src/intel/compiler/brw_fs_visitor.cpp
@@ -727,7 +727,13 @@ fs_visitor::emit_urb_writes(const fs_reg &gs_vertex_count)
                            header_size);
 
          fs_inst *inst = abld.emit(opcode, reg_undef, payload);
-         inst->eot = slot == last_slot && stage != MESA_SHADER_GEOMETRY;
+
+         /* For ICL WA 1805992985 one needs additional write in the end. */
+         if (devinfo->gen == 11 && stage == MESA_SHADER_TESS_EVAL)
+            inst->eot = false;
+         else
+            inst->eot = slot == last_slot && stage != MESA_SHADER_GEOMETRY;
+
          inst->mlen = length + header_size;
          inst->offset = urb_offset;
          urb_offset = starting_urb_offset + slot + 1;
@@ -763,6 +769,49 @@ fs_visitor::emit_urb_writes(const fs_reg &gs_vertex_count)
       inst->mlen = 2;
       inst->offset = 1;
       return;
+   } 
+ 
+   /* ICL WA 1805992985:
+    *
+    * ICLLP GPU hangs on one of tessellation vkcts tests with DS not done. The
+    * send cycle, which is a urb write with an eot must be 4 phases long and
+    * all 8 lanes must valid.
+    */
+   if (devinfo->gen == 11 && stage == MESA_SHADER_TESS_EVAL) {
+      fs_reg payload = fs_reg(VGRF, alloc.allocate(6), BRW_REGISTER_TYPE_UD);
+
+      /* Workaround requires all 8 channels (lanes) to be valid. This is
+       * understood to mean they all need to be alive. First trick is to find
+       * a live channel and copy its urb handle for all the other channels to
+       * make sure all handles are valid.
+       */
+      bld.exec_all().MOV(payload, bld.emit_uniformize(urb_handle));
+
+      /* Second trick is to use masked URB write where one can tell the HW to
+       * actually write data only for selected channels even though all are
+       * active.
+       * Third trick is to take advantage of the must-be-zero (MBZ) area in
+       * the very beginning of the URB.
+       *
+       * One masks data to be written only for the first channel and uses
+       * offset zero explicitly to land data to the MBZ area avoiding trashing
+       * any other part of the URB.
+       *
+       * Since the WA says that the write needs to be 4 phases long one uses
+       * 4 slots data. All are explicitly zeros in order to to keep the MBZ
+       * area written as zeros.
+       */
+      bld.exec_all().MOV(offset(payload, bld, 1), brw_imm_ud(0x10000u));
+      bld.exec_all().MOV(offset(payload, bld, 2), brw_imm_ud(0u));
+      bld.exec_all().MOV(offset(payload, bld, 3), brw_imm_ud(0u));
+      bld.exec_all().MOV(offset(payload, bld, 4), brw_imm_ud(0u));
+      bld.exec_all().MOV(offset(payload, bld, 5), brw_imm_ud(0u));
+
+      fs_inst *inst = bld.exec_all().emit(SHADER_OPCODE_URB_WRITE_SIMD8_MASKED,
+                                          reg_undef, payload);
+      inst->eot = true;
+      inst->mlen = 6;
+      inst->offset = 0;
    }
 }
 
diff --git a/src/intel/genxml/gen10.xml b/src/intel/genxml/gen10.xml
index 4cb1f05ae25..9aa14afdcd2 100644
--- a/src/intel/genxml/gen10.xml
+++ b/src/intel/genxml/gen10.xml
@@ -84,6 +84,40 @@
     <value name="XYZW" value="15"/>
   </enum>
 
+  <enum name="Atomic_OPCODE" prefix="MI_ATOMIC_OP">
+    <value name="AND" value="0x01"/>
+    <value name="OR" value="0x02"/>
+    <value name="XOR" value="0x03"/>
+    <value name="MOVE" value="0x04"/>
+    <value name="INC" value="0x05"/>
+    <value name="DEC" value="0x06"/>
+    <value name="ADD" value="0x07"/>
+    <value name="SUB" value="0x08"/>
+    <value name="RSUB" value="0x09"/>
+    <value name="IMAX" value="0x0a"/>
+    <value name="IMIN" value="0x0b"/>
+    <value name="UMAX" value="0x0c"/>
+    <value name="UMIN" value="0x0d"/>
+    <value name="CMP_WR" value="0x0e"/>
+    <value name="PREDEC" value="0x0f"/>
+    <value name="AND8B" value="0x21"/>
+    <value name="OR8B" value="0x22"/>
+    <value name="XOR8B" value="0x23"/>
+    <value name="MOVE8B" value="0x24"/>
+    <value name="INC8B" value="0x25"/>
+    <value name="DEC8B" value="0x26"/>
+    <value name="ADD8B" value="0x27"/>
+    <value name="SUB8B" value="0x28"/>
+    <value name="RSUB8B" value="0x29"/>
+    <value name="IMAX8B" value="0x2a"/>
+    <value name="IMIN8B" value="0x2b"/>
+    <value name="UMAX8B" value="0x2c"/>
+    <value name="UMIN8B" value="0x2d"/>
+    <value name="CMP_WR8B" value="0x2e"/>
+    <value name="PREDEC8B" value="0x2f"/>
+    <value name="CMP_WR16B" value="0x4e"/>
+  </enum>
+
   <enum name="Attribute_Component_Format" prefix="ACF">
     <value name="disabled" value="0"/>
     <value name=".xy" value="1"/>
@@ -2838,16 +2872,16 @@
       <value name="Global Graphics Address" value="1"/>
     </field>
     <field name="Post-Sync Operation" start="21" end="21" type="bool"/>
-    <field name="Data Size" start="19" end="20" type="uint">
+    <field name="Data Size" start="19" end="20" type="uint" prefix="MI_ATOMIC">
       <value name="DWORD" value="0"/>
       <value name="QWORD" value="1"/>
       <value name="OCTWORD" value="2"/>
       <value name="RESERVED" value="3"/>
     </field>
-    <field name="Inline Data" start="18" end="18" type="uint"/>
-    <field name="CS STALL" start="17" end="17" type="uint"/>
-    <field name="Return Data Control" start="16" end="16" type="uint"/>
-    <field name="ATOMIC OPCODE" start="8" end="15" type="uint"/>
+    <field name="Inline Data" start="18" end="18" type="bool"/>
+    <field name="CS STALL" start="17" end="17" type="bool"/>
+    <field name="Return Data Control" start="16" end="16" type="bool"/>
+    <field name="ATOMIC OPCODE" start="8" end="15" type="Atomic_OPCODE"/>
     <field name="DWord Length" start="0" end="7" type="uint" default="1"/>
     <field name="Memory Address" start="34" end="79" type="address"/>
     <field name="Operand1 Data Dword 0" start="96" end="127" type="uint"/>
diff --git a/src/intel/genxml/gen11.xml b/src/intel/genxml/gen11.xml
index a7c06c5ab60..23abb578270 100644
--- a/src/intel/genxml/gen11.xml
+++ b/src/intel/genxml/gen11.xml
@@ -84,6 +84,40 @@
     <value name="XYZW" value="15"/>
   </enum>
 
+  <enum name="Atomic_OPCODE" prefix="MI_ATOMIC_OP">
+    <value name="AND" value="0x01"/>
+    <value name="OR" value="0x02"/>
+    <value name="XOR" value="0x03"/>
+    <value name="MOVE" value="0x04"/>
+    <value name="INC" value="0x05"/>
+    <value name="DEC" value="0x06"/>
+    <value name="ADD" value="0x07"/>
+    <value name="SUB" value="0x08"/>
+    <value name="RSUB" value="0x09"/>
+    <value name="IMAX" value="0x0a"/>
+    <value name="IMIN" value="0x0b"/>
+    <value name="UMAX" value="0x0c"/>
+    <value name="UMIN" value="0x0d"/>
+    <value name="CMP_WR" value="0x0e"/>
+    <value name="PREDEC" value="0x0f"/>
+    <value name="AND8B" value="0x21"/>
+    <value name="OR8B" value="0x22"/>
+    <value name="XOR8B" value="0x23"/>
+    <value name="MOVE8B" value="0x24"/>
+    <value name="INC8B" value="0x25"/>
+    <value name="DEC8B" value="0x26"/>
+    <value name="ADD8B" value="0x27"/>
+    <value name="SUB8B" value="0x28"/>
+    <value name="RSUB8B" value="0x29"/>
+    <value name="IMAX8B" value="0x2a"/>
+    <value name="IMIN8B" value="0x2b"/>
+    <value name="UMAX8B" value="0x2c"/>
+    <value name="UMIN8B" value="0x2d"/>
+    <value name="CMP_WR8B" value="0x2e"/>
+    <value name="PREDEC8B" value="0x2f"/>
+    <value name="CMP_WR16B" value="0x4e"/>
+  </enum>
+
   <enum name="Attribute_Component_Format" prefix="ACF">
     <value name="disabled" value="0"/>
     <value name=".xy" value="1"/>
@@ -2804,16 +2838,16 @@
       <value name="Global Graphics Address" value="1"/>
     </field>
     <field name="Post-Sync Operation" start="21" end="21" type="bool"/>
-    <field name="Data Size" start="19" end="20" type="uint">
+    <field name="Data Size" start="19" end="20" type="uint" prefix="MI_ATOMIC">
       <value name="DWORD" value="0"/>
       <value name="QWORD" value="1"/>
       <value name="OCTWORD" value="2"/>
       <value name="RESERVED" value="3"/>
     </field>
-    <field name="Inline Data" start="18" end="18" type="uint"/>
-    <field name="CS STALL" start="17" end="17" type="uint"/>
-    <field name="Return Data Control" start="16" end="16" type="uint"/>
-    <field name="ATOMIC OPCODE" start="8" end="15" type="uint"/>
+    <field name="Inline Data" start="18" end="18" type="bool"/>
+    <field name="CS STALL" start="17" end="17" type="bool"/>
+    <field name="Return Data Control" start="16" end="16" type="bool"/>
+    <field name="ATOMIC OPCODE" start="8" end="15" type="Atomic_OPCODE"/>
     <field name="DWord Length" start="0" end="7" type="uint" default="1"/>
     <field name="Memory Address" start="34" end="79" type="address"/>
     <field name="Operand1 Data Dword 0" start="96" end="127" type="uint"/>
diff --git a/src/intel/genxml/gen9.xml b/src/intel/genxml/gen9.xml
index 88fc2da7885..0cbf4ea6639 100644
--- a/src/intel/genxml/gen9.xml
+++ b/src/intel/genxml/gen9.xml
@@ -84,6 +84,40 @@
     <value name="XYZW" value="15"/>
   </enum>
 
+  <enum name="Atomic_OPCODE" prefix="MI_ATOMIC_OP">
+    <value name="AND" value="0x01"/>
+    <value name="OR" value="0x02"/>
+    <value name="XOR" value="0x03"/>
+    <value name="MOVE" value="0x04"/>
+    <value name="INC" value="0x05"/>
+    <value name="DEC" value="0x06"/>
+    <value name="ADD" value="0x07"/>
+    <value name="SUB" value="0x08"/>
+    <value name="RSUB" value="0x09"/>
+    <value name="IMAX" value="0x0a"/>
+    <value name="IMIN" value="0x0b"/>
+    <value name="UMAX" value="0x0c"/>
+    <value name="UMIN" value="0x0d"/>
+    <value name="CMP_WR" value="0x0e"/>
+    <value name="PREDEC" value="0x0f"/>
+    <value name="AND8B" value="0x21"/>
+    <value name="OR8B" value="0x22"/>
+    <value name="XOR8B" value="0x23"/>
+    <value name="MOVE8B" value="0x24"/>
+    <value name="INC8B" value="0x25"/>
+    <value name="DEC8B" value="0x26"/>
+    <value name="ADD8B" value="0x27"/>
+    <value name="SUB8B" value="0x28"/>
+    <value name="RSUB8B" value="0x29"/>
+    <value name="IMAX8B" value="0x2a"/>
+    <value name="IMIN8B" value="0x2b"/>
+    <value name="UMAX8B" value="0x2c"/>
+    <value name="UMIN8B" value="0x2d"/>
+    <value name="CMP_WR8B" value="0x2e"/>
+    <value name="PREDEC8B" value="0x2f"/>
+    <value name="CMP_WR16B" value="0x4e"/>
+  </enum>
+
   <enum name="Attribute_Component_Format" prefix="ACF">
     <value name="disabled" value="0"/>
     <value name=".xy" value="1"/>
@@ -2758,16 +2792,16 @@
       <value name="Global Graphics Address" value="1"/>
     </field>
     <field name="Post-Sync Operation" start="21" end="21" type="bool"/>
-    <field name="Data Size" start="19" end="20" type="uint">
+    <field name="Data Size" start="19" end="20" type="uint" prefix="MI_ATOMIC">
       <value name="DWORD" value="0"/>
       <value name="QWORD" value="1"/>
       <value name="OCTWORD" value="2"/>
       <value name="RESERVED" value="3"/>
     </field>
-    <field name="Inline Data" start="18" end="18" type="uint"/>
-    <field name="CS STALL" start="17" end="17" type="uint"/>
-    <field name="Return Data Control" start="16" end="16" type="uint"/>
-    <field name="ATOMIC OPCODE" start="8" end="15" type="uint"/>
+    <field name="Inline Data" start="18" end="18" type="bool"/>
+    <field name="CS STALL" start="17" end="17" type="bool"/>
+    <field name="Return Data Control" start="16" end="16" type="bool"/>
+    <field name="ATOMIC OPCODE" start="8" end="15" type="Atomic_OPCODE"/>
     <field name="DWord Length" start="0" end="7" type="uint" default="1"/>
     <field name="Memory Address" start="34" end="79" type="address"/>
     <field name="Operand1 Data Dword 0" start="96" end="127" type="uint"/>
diff --git a/src/intel/isl/isl.c b/src/intel/isl/isl.c
index 7bb0fce3b60..4f0668359d7 100644
--- a/src/intel/isl/isl.c
+++ b/src/intel/isl/isl.c
@@ -119,7 +119,8 @@ isl_device_init(struct isl_device *dev,
    dev->ss.size = RENDER_SURFACE_STATE_length(info) * 4;
    dev->ss.align = isl_align(dev->ss.size, 32);
 
-   dev->ss.clear_color_state_size = CLEAR_COLOR_length(info) * 4;
+   dev->ss.clear_color_state_size =
+      isl_align(CLEAR_COLOR_length(info) * 4, 64);
    dev->ss.clear_color_state_offset =
       RENDER_SURFACE_STATE_ClearValueAddress_start(info) / 32 * 4;
 
diff --git a/src/intel/isl/isl_surface_state.c b/src/intel/isl/isl_surface_state.c
index 7ab260d701b..86b132a26ba 100644
--- a/src/intel/isl/isl_surface_state.c
+++ b/src/intel/isl/isl_surface_state.c
@@ -618,6 +618,27 @@ isl_genX(surf_fill_state_s)(const struct isl_device *dev, void *state,
          unreachable("Gen9 and earlier do not support indirect clear colors");
 #endif
       }
+
+#if GEN_GEN == 11
+      /*
+       * From BXML > GT > Shared Functions > vol5c Shared Functions >
+       * [Structure] RENDER_SURFACE_STATE [BDW+] > ClearColorConversionEnable:
+       *
+       *   Project: Gen11
+       *
+       *   "Enables Pixel backend hw to convert clear values into native format
+       *    and write back to clear address, so that display and sampler can use
+       *    the converted value for resolving fast cleared RTs."
+       *
+       * Summary:
+       *   Clear color conversion must be enabled if the clear color is stored
+       *   indirectly and fast color clears are enabled.
+       */
+      if (info->use_clear_address) {
+         s.ClearColorConversionEnable = true;
+      }
+#endif
+
 #if GEN_GEN >= 9
       if (!info->use_clear_address) {
          s.RedClearColor = info->clear_color.u32[0];
diff --git a/src/intel/vulkan/anv_device.c b/src/intel/vulkan/anv_device.c
index 99b512a0387..dc961847a63 100644
--- a/src/intel/vulkan/anv_device.c
+++ b/src/intel/vulkan/anv_device.c
@@ -366,10 +366,8 @@ anv_physical_device_init(struct anv_physical_device *device,
       intel_logw("Ivy Bridge Vulkan support is incomplete");
    } else if (device->info.gen == 7 && device->info.is_baytrail) {
       intel_logw("Bay Trail Vulkan support is incomplete");
-   } else if (device->info.gen >= 8 && device->info.gen <= 10) {
-      /* Gen8-10 fully supported */
-   } else if (device->info.gen == 11) {
-      intel_logw("Vulkan is not yet fully supported on gen11.");
+   } else if (device->info.gen >= 8 && device->info.gen <= 11) {
+      /* Gen8-11 fully supported */
    } else {
       result = vk_errorf(device->instance, device,
                          VK_ERROR_INCOMPATIBLE_DRIVER,
diff --git a/src/mesa/drivers/dri/i965/brw_blorp.c b/src/mesa/drivers/dri/i965/brw_blorp.c
index 97a5f6a9937..428c88fcf87 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp.c
+++ b/src/mesa/drivers/dri/i965/brw_blorp.c
@@ -1276,11 +1276,6 @@ do_single_blorp_clear(struct brw_context *brw, struct gl_framebuffer *fb,
       }
    }
 
-   /* FINISHME: Debug and enable fast clears */
-   const struct gen_device_info *devinfo = &brw->screen->devinfo;
-   if (devinfo->gen >= 11)
-      can_fast_clear = false;
-
    if (can_fast_clear) {
       const enum isl_aux_state aux_state =
          intel_miptree_get_aux_state(irb->mt, irb->mt_level, irb->mt_layer);
@@ -1288,13 +1283,13 @@ do_single_blorp_clear(struct brw_context *brw, struct gl_framebuffer *fb,
          brw_meta_convert_fast_clear_color(brw, irb->mt,
                                            &ctx->Color.ClearColor);
 
-      intel_miptree_set_clear_color(brw, irb->mt, clear_color);
-
-      /* If the buffer is already in ISL_AUX_STATE_CLEAR, the clear
-       * is redundant and can be skipped.
+      /* If the buffer is already in ISL_AUX_STATE_CLEAR and the clear color
+       * hasn't changed, the clear is redundant and can be skipped.
        */
-      if (aux_state == ISL_AUX_STATE_CLEAR)
+      if (!intel_miptree_set_clear_color(brw, irb->mt, clear_color) &&
+          aux_state == ISL_AUX_STATE_CLEAR) {
          return;
+      }
 
       DBG("%s (fast) to mt %p level %d layers %d+%d\n", __FUNCTION__,
           irb->mt, irb->mt_level, irb->mt_layer, num_layers);
@@ -1320,11 +1315,9 @@ do_single_blorp_clear(struct brw_context *brw, struct gl_framebuffer *fb,
       brw_emit_end_of_pipe_sync(brw, PIPE_CONTROL_RENDER_TARGET_FLUSH);
 
       struct blorp_batch batch;
-      blorp_batch_init(&brw->blorp, &batch, brw,
-                       BLORP_BATCH_NO_UPDATE_CLEAR_COLOR);
-      blorp_fast_clear(&batch, &surf, isl_format,
-                       level, irb->mt_layer, num_layers,
-                       x0, y0, x1, y1);
+      blorp_batch_init(&brw->blorp, &batch, brw, 0);
+      blorp_fast_clear(&batch, &surf, isl_format_srgb_to_linear(isl_format),
+                       level, irb->mt_layer, num_layers, x0, y0, x1, y1);
       blorp_batch_finish(&batch);
 
       brw_emit_end_of_pipe_sync(brw, PIPE_CONTROL_RENDER_TARGET_FLUSH);
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 505da9896b3..c3fffd4c797 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -1059,13 +1059,6 @@ brwCreateContext(gl_api api,
       return false;
    }
 
-   if (devinfo->gen == 11) {
-      fprintf(stderr,
-              "WARNING: i965 does not fully support Gen11 yet.\n"
-              "Instability or lower performance might occur.\n");
-
-   }
-
    brw_upload_init(&brw->upload, brw->bufmgr, 65536);
 
    brw_init_state(brw);
diff --git a/src/mesa/drivers/dri/i965/genX_state_upload.c b/src/mesa/drivers/dri/i965/genX_state_upload.c
index 73c983ce742..b393aeb9152 100644
--- a/src/mesa/drivers/dri/i965/genX_state_upload.c
+++ b/src/mesa/drivers/dri/i965/genX_state_upload.c
@@ -2051,8 +2051,7 @@ genX(upload_wm)(struct brw_context *brw)
       if (wm_prog_data->base.use_alt_mode)
          wm.FloatingPointMode = FLOATING_POINT_MODE_Alternate;
 
-      /* WA_1606682166 */
-      wm.SamplerCount = (GEN_GEN == 5 || GEN_GEN == 11) ?
+      wm.SamplerCount = GEN_GEN == 5 ?
          0 : DIV_ROUND_UP(stage_state->sampler_count, 4);
 
       wm.BindingTableEntryCount =
@@ -4561,7 +4560,9 @@ genX(upload_cs_state)(struct brw_context *brw)
    const struct GENX(INTERFACE_DESCRIPTOR_DATA) idd = {
       .KernelStartPointer = brw->cs.base.prog_offset,
       .SamplerStatePointer = stage_state->sampler_offset,
-      .SamplerCount = DIV_ROUND_UP(CLAMP(stage_state->sampler_count, 0, 16), 4),
+      /* WA_1606682166 */
+      .SamplerCount = GEN_GEN == 11 ? 0 :
+                      DIV_ROUND_UP(CLAMP(stage_state->sampler_count, 0, 16), 4),
       .BindingTablePointer = stage_state->bind_bo_offset,
       .ConstantURBEntryReadLength = cs_prog_data->push.per_thread.regs,
       .NumberofThreadsinGPGPUThreadGroup = cs_prog_data->threads,
